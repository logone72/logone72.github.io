<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React Server Components에 대한 오해 | 기술 블로그</title>
    <meta name="description" content="frontend developer logone72's blog">
    <meta name="generator" content="VitePress v2.0.0-alpha.12">
    <link rel="preload stylesheet" href="/assets/style.Cr6nQ1YR.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.DW3izckF.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.B6QYPDOf.js">
    <link rel="modulepreload" href="/assets/chunks/framework.EaxRB2c3.js">
    <link rel="modulepreload" href="/assets/아티클_React_Server_Components에_대한_오해.md.DgCUfbcE.lean.js">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BG56ZW302R"></script>
    <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BG56ZW302R");</script>
    <meta name="naver-site-verification" content="67ff08576a160f454495df90f7f4021201a0b4da">
    <link rel="icon" href="/favicon.ico">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-1df9f90f><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0b0ada53></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0b0ada53>Skip to content</a><!--]--><!----><header class="VPNav" data-v-1df9f90f data-v-9f75dce3><div class="VPNavBar" data-v-9f75dce3 data-v-2a96a3d0><div class="wrapper" data-v-2a96a3d0><div class="container" data-v-2a96a3d0><div class="title" data-v-2a96a3d0><div class="VPNavBarTitle has-sidebar" data-v-2a96a3d0 data-v-1e38c6bc><a class="title" href="/" data-v-1e38c6bc><!--[--><!--]--><!--[--><img class="VPImage logo" src="/icons8-dev-30.png" alt data-v-8426fc1a><!--]--><span data-v-1e38c6bc>logone72</span><!--[--><!--]--></a></div></div><div class="content" data-v-2a96a3d0><div class="content-body" data-v-2a96a3d0><!--[--><!--]--><div class="VPNavBarSearch search" data-v-2a96a3d0><!--[--><!----><div id="local-search"><button type="button" aria-label="Search" aria-keyshortcuts="/ control+k meta+k" class="DocSearch DocSearch-Button"><span class="DocSearch-Button-Container"><span class="vpi-search DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key"></kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-2a96a3d0 data-v-39714824><span id="main-nav-aria-label" class="visually-hidden" data-v-39714824> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-39714824 data-v-e56f3d57><!--[--><span data-v-e56f3d57>Home</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-2a96a3d0 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-2a96a3d0 data-v-0394ad82 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/logone72/logone72.github.io.git" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-2a96a3d0 data-v-bb2aa2f0 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-42cb505d><span class="vpi-more-horizontal icon" data-v-42cb505d></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/logone72/logone72.github.io.git" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-2a96a3d0 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-2a96a3d0><div class="divider-line" data-v-2a96a3d0></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-1df9f90f data-v-8acdfeb5><div class="container" data-v-8acdfeb5><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-8acdfeb5><span class="vpi-align-left menu-icon" data-v-8acdfeb5></span><span class="menu-text" data-v-8acdfeb5>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-8acdfeb5 data-v-0bf0e06f><button data-v-0bf0e06f>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-1df9f90f data-v-e7c6e512><div class="curtain" data-v-e7c6e512></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-e7c6e512><span class="visually-hidden" id="sidebar-aria-label" data-v-e7c6e512> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-8d50c081><section class="VPSidebarItem level-0" data-v-8d50c081 data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h2 class="text" data-v-d81de50c>블로그</h2><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/%EB%B8%94%EB%A1%9C%EA%B7%B8/obsidian%EC%9C%BC%EB%A1%9C_%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94_VitePress_%EB%B8%94%EB%A1%9C%EA%B7%B8" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>obsidian으로 작성하는 VitePress 블로그</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-8d50c081><section class="VPSidebarItem level-0 has-active" data-v-8d50c081 data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h2 class="text" data-v-d81de50c>아티클</h2><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/%EC%95%84%ED%8B%B0%ED%81%B4/CSS_Cascading_and_Specificity" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>CSS Cascading and Specificity</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/%EC%95%84%ED%8B%B0%ED%81%B4/React_Server_Components%EC%97%90_%EB%8C%80%ED%95%9C_%EC%98%A4%ED%95%B4" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>React Server Components에 대한 오해</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/%EC%95%84%ED%8B%B0%ED%81%B4/javascript%EC%9D%98_%EC%95%8C%EB%A9%B4_%EB%BB%94%ED%95%98%EC%A7%80%EB%A7%8C_%EB%AA%B0%EB%9E%90%EC%9D%84_%EC%88%98%EB%8F%84_%EC%9E%88%EB%8A%94_%EB%8F%99%EC%9E%91" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>javascript의 알면 뻔하지만 몰랐을 수도 있는 동작</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/%EC%95%84%ED%8B%B0%ED%81%B4/%EC%BD%94%EB%93%9C_%EB%B3%B5%EC%9E%A1%EB%8F%84%EB%A5%BC_%EC%B8%A1%EC%A0%95%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>코드 복잡도를 측정하는 방법</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/%EC%95%84%ED%8B%B0%ED%81%B4/%ED%95%9C%EA%B8%80_%ED%8C%8C%EC%9D%BC%EB%AA%85%EC%9D%B4_%EC%9D%BD%ED%9E%88%EC%A7%80_%EC%95%8A%EB%8A%94_%EB%AC%B8%EC%A0%9C" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>한글 파일명이 읽히지 않는 문제</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-1df9f90f data-v-aff0b8d7><div class="VPDoc has-sidebar has-aside" data-v-aff0b8d7 data-v-7011f0d8><!--[--><!--]--><div class="container" data-v-7011f0d8><div class="aside" data-v-7011f0d8><div class="aside-curtain" data-v-7011f0d8></div><div class="aside-container" data-v-7011f0d8><div class="aside-content" data-v-7011f0d8><div class="VPDocAside" data-v-7011f0d8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-60d5052e><div class="content" data-v-60d5052e><div class="outline-marker" data-v-60d5052e></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-60d5052e>On this page</div><ul class="VPDocOutlineItem root" data-v-60d5052e data-v-2d0bdf9b><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-7011f0d8><div class="content-container" data-v-7011f0d8><!--[--><!--]--><main class="main" data-v-7011f0d8><div style="position:relative;" class="vp-doc _%EC%95%84%ED%8B%B0%ED%81%B4_React_Server_Components%EC%97%90_%EB%8C%80%ED%95%9C_%EC%98%A4%ED%95%B4" data-v-7011f0d8><div><h1 id="react-server-components에-대한-오해" tabindex="-1">React Server Components에 대한 오해 <a class="header-anchor" href="#react-server-components에-대한-오해" aria-label="Permalink to “React Server Components에 대한 오해”">​</a></h1><p><img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/f_auto/v1617437062/patterns.dev/reactServerComponents.png" alt=""></p><p><strong>React Server Components(RSC)</strong> 라는 명칭을 보면서 아래와 같은 궁금증이 개인적으로 생겼었습니다.</p><blockquote><p>“React가 풀스택 프레임워크가 된 건가?”</p></blockquote><p>하지만 실제로 React 19를 조금만 자세히 들여다보면, 이야기가 달랐습니다.<br> React는 여전히 <strong>UI 라이브러리</strong>이고, 풀스택의 모든 부분을 담당하는 건 <strong>Next.js</strong> 같은 프레임워크의 몫입니다.</p><p>다만, 이번에는 그 둘이 훨씬 더 깊게 연결되었습니다.</p><p>React가 직접 “서버-클라이언트 경계를 어떻게 정의하고, 어떤 데이터를 주고받을지”에 대한 <strong>표준 언어</strong>를 만든 것이죠.</p><h2 id="rsc는-새로운-프레임워크가-아니라-렌더링-모델-입니다" tabindex="-1">RSC는 새로운 프레임워크가 아니라 “렌더링 모델”입니다 <a class="header-anchor" href="#rsc는-새로운-프레임워크가-아니라-렌더링-모델-입니다" aria-label="Permalink to “RSC는 새로운 프레임워크가 아니라 “렌더링 모델”입니다”">​</a></h2><p>RSC는 “React가 서버에서 돌아가는 새로운 버전”이 아닙니다.<br> 그보다는, <strong>React 컴포넌트를 어디에서, 어떤 방식으로 렌더링할지 정의한 모델</strong>이라고 이해하시면 좋습니다.</p><p>핵심 개념은 단순합니다.</p><blockquote><p>“일부 React 컴포넌트는 브라우저가 아니라 서버에서 렌더링할 수 있다.”</p></blockquote><p>여기서 서버란 웹 서버만을 지칭하지 않습니다. <strong>Server Component</strong>는 번들링 전에 클라이언트 애플리케이션 또는 SSR 서버와 분리된 환경에서 컴포넌트를 미리 렌더링할 수 있는 새로운 옵션입니다. 이 별도의 환경이 RSC에서 <strong>“서버”</strong> 입니다.</p><p>예를 들어 아래 코드를 보겠습니다.</p><div class="language-tsx"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// app/page.tsx</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UserCard </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./UserCard&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://api.example.com/me&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello, {user.name}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UserCard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 컴포넌트는 <strong>Server Component</strong>로 동작합니다.<br> 데이터 패칭(<code>fetch</code>)은 서버에서 이루어지고, React는 이 컴포넌트를 서버에서 렌더링한 뒤 그 결과를 브라우저로 스트리밍합니다.</p><p>이때 브라우저로 전송되는 건 완성된 HTML이 아니라, <strong>RSC Payload(Flight Data)</strong> 라는 React 고유의 데이터 포맷입니다. React DOM은 서버에서 전달된 RSC Payload를 해석해, 클라이언트에서 이미 로드된 컴포넌트 트리와 병합합니다.</p><p>즉, RSC는 전통적인 SSR(Server-Side Rendering)과는 다릅니다.</p><p>전통적인 SSR은 서버에서 HTML을 완성해 보내지만, RSC는 서버에서 React 트리를 렌더링하고, 그 결과를 Flight 포맷으로 직렬화해 브라우저로 전송합니다. 브라우저에서는 이 데이터를 React DOM이 해석해 클라이언트 트리와 병합(hydration과 유사하지만 다른)합니다.</p><h2 id="rsc는-ssr을-대체하는-것인가요" tabindex="-1">RSC는 SSR을 대체하는 것인가요? <a class="header-anchor" href="#rsc는-ssr을-대체하는-것인가요" aria-label="Permalink to “RSC는 SSR을 대체하는 것인가요?”">​</a></h2><p>그렇다면 RSC를 사용하면 이제 SSR이 필요 없을까요? 그렇지 않습니다.</p><p>실제로는 <strong>RSC와 SSR은 서로 다른 층(layer)에 존재하는 개념</strong>입니다.</p><p>SSR은 <strong>“어디서 HTML을 생성하느냐”</strong> 에 관한 이야기이고, RSC는 <strong>“어디서 어떤 컴포넌트를 실행하느냐”</strong> 에 관한 이야기입니다.</p><p>즉, SSR은 렌더링 결과물(HTML)의 생성 위치를 다루고, RSC는 렌더링 과정에서의 <strong>컴포넌트 실행 위치(서버 vs 클라이언트)</strong> 를 다룹니다.</p><p>그래서 RSC를 사용한다고 해서 SSR이 사라지는 것은 아닙니다.</p><p>대신 두 기술은 <strong>서로를 보완하며 함께 동작</strong>합니다.</p><p>예를 들어, SSR은 첫 화면의 HTML을 빠르게 전달하고, RSC는 그 안의 React 트리를 서버에서 효율적으로 렌더링해 스트리밍합니다.</p><h2 id="react-19가-rsc를-지원한다-는-말의-의미" tabindex="-1">React 19가 “RSC를 지원한다”는 말의 의미 <a class="header-anchor" href="#react-19가-rsc를-지원한다-는-말의-의미" aria-label="Permalink to “React 19가 “RSC를 지원한다”는 말의 의미”">​</a></h2><p>React 19가 RSC를 안정적으로 지원한다는 건 이제 React 자체가 서버에서 날아오는 RSC 데이터를 <strong>이해하고 조립할 수 있는 런타임</strong>을 내장하게 되었다는 뜻입니다.</p><p>React 19에는 이런 기능들이 새롭게 들어왔습니다.</p><ul><li><strong>RSC Payload(Flight protocol) 디코딩 기능</strong></li><li><strong><code>react-server</code> export condition</strong> (서버 전용 모듈 인식)</li><li><strong><code>use</code> 훅</strong> (Promise를 <code>Suspense</code>와 함께 다루기)</li><li><strong>Server Actions</strong> (클라이언트에서 서버 함수를 호출)</li><li><strong><code>&lt;form action&gt;</code> 통합</strong> (서버 액션과 폼 제출 연결)</li><li><strong>스타일 및 메타데이터 호이스팅</strong> (SSR과 CSR 간 일관성 보장)</li></ul><p>이 모든 것은 프레임워크가 구현하기 위한 <strong>표준 인터페이스</strong>로 제공됩니다. 즉, React 19는 이제 “RSC를 해석하고 관리할 수 있는 공통 엔진”을 갖게 된 것입니다.</p><h2 id="프레임워크는-여전히-필요합니다" tabindex="-1">프레임워크는 여전히 필요합니다 <a class="header-anchor" href="#프레임워크는-여전히-필요합니다" aria-label="Permalink to “프레임워크는 여전히 필요합니다”">​</a></h2><p>React가 RSC의 표준을 제시했다고 해서, React 혼자서 모든 걸 처리하는 것은 아닙니다.</p><p>다음과 같은 부분들은 여전히 프레임워크나 번들러가 담당합니다.</p><table tabindex="0"><thead><tr><th>역할</th><th>담당</th></tr></thead><tbody><tr><td>라우팅 및 페이지 구성</td><td>Next.js, Remix</td></tr><tr><td>서버 실행 및 스트리밍 응답</td><td>Next.js</td></tr><tr><td>번들 분리 (<code>use client</code>, <code>use server</code>)</td><td>Webpack, Vite, Turbopack</td></tr><tr><td>캐싱, 재검증, 데이터 패칭</td><td>프레임워크</td></tr><tr><td>빌드 및 배포</td><td>인프라 도구들</td></tr></tbody></table><p>React는 <strong>“표준 언어”를 제공</strong>하고, 그 언어로 “앱”을 구성하는 것은 프레임워크의 일입니다.</p><p>이 점에서 React는 여전히 <strong>“UI 라이브러리”</strong> 의 철학을 유지하고 있습니다.</p><h2 id="next-js-app-router-rsc의-첫-번째-실험실" tabindex="-1">Next.js App Router: RSC의 첫 번째 실험실 <a class="header-anchor" href="#next-js-app-router-rsc의-첫-번째-실험실" aria-label="Permalink to “Next.js App Router: RSC의 첫 번째 실험실”">​</a></h2><p>Next.js가 <strong>App Router</strong>를 발표했을 때, 그건 사실 React Server Component를 세상에서 가장 먼저, 그리고 가장 깊이 실험한 사례였습니다.</p><p>App Router는 React 18을 기반으로 만들어졌지만, RSC는 당시 React 18의 정식 API가 아니었습니다.<br> 그래서 Next.js는 React의 <strong>canary(실험)</strong> 버전을 직접 가져다 썼습니다.</p><div class="language-perl"><button title="Copy Code" class="copy"></button><span class="lang">perl</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@13</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">└── react@canary</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ├─ RSC 런타임(Flight 디코더)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ├─ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() 훅</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ├─ Server Actions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    └─ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> server / </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> client</span></span></code></pre></div><p>즉, App Router는 React의 공식 API를 쓰지 않고, React 내부 코드를 직접 활용했던 일종의 <strong>실험적 구현체</strong>였습니다.</p><p>그래서 “안정 버전”이 아닌 “실험적 기능”으로 분류될 수밖에 없었습니다.</p><h2 id="react-19에서-app-router가-완전히-자리를-잡았습니다" tabindex="-1">React 19에서 App Router가 완전히 자리를 잡았습니다 <a class="header-anchor" href="#react-19에서-app-router가-완전히-자리를-잡았습니다" aria-label="Permalink to “React 19에서 App Router가 완전히 자리를 잡았습니다”">​</a></h2><p>React 19에서는 Next.js가 실험적으로 의존하던 기능들이 모두 React의 정식 API로 편입되었습니다.</p><table tabindex="0"><thead><tr><th>기능</th><th>React 18 시절</th><th>React 19 이후</th></tr></thead><tbody><tr><td>RSC payload 디코딩</td><td>Next.js 내부 구현</td><td>React DOM 내장</td></tr><tr><td><code>use</code> 훅</td><td>실험적</td><td>정식</td></tr><tr><td>Server Actions</td><td>실험적</td><td>정식</td></tr><tr><td><code>react-server</code> 조건</td><td>없음</td><td>정식</td></tr><tr><td><code>&lt;form action&gt;</code> 통합</td><td>Next.js 전용</td><td>React DOM 지원</td></tr><tr><td>메타데이터/스타일 호이스팅</td><td>Next.js 내부 처리</td><td>React DOM 내장</td></tr></tbody></table><p>이제 App Router는 React의 정식 버전만으로도 안정적으로 작동합니다.<br> React와 Next.js가 각자 독립적으로 발전하면서도, <strong>RSC라는 표준 언어로 완전히 호환</strong>되는 구조가 된 것입니다.</p><h2 id="react와-next-js의-역할이-다시-명확해졌습니다" tabindex="-1">React와 Next.js의 역할이 다시 명확해졌습니다 <a class="header-anchor" href="#react와-next-js의-역할이-다시-명확해졌습니다" aria-label="Permalink to “React와 Next.js의 역할이 다시 명확해졌습니다”">​</a></h2><p>React 19 이후 두 프로젝트의 관계는 다음과 같이 정리됩니다.</p><table tabindex="0"><thead><tr><th>계층</th><th>역할</th><th>담당</th></tr></thead><tbody><tr><td>React Core</td><td>RSC 런타임, Flight 프로토콜, Suspense, Server Actions 등</td><td>React</td></tr><tr><td>Integration Layer</td><td>RSC 렌더링, 스트리밍, 번들 매핑</td><td>Next.js</td></tr><tr><td>Routing &amp; Data Layer</td><td>파일 라우팅, 캐싱, 데이터 패칭</td><td>Next.js</td></tr><tr><td>Build &amp; Infra</td><td>번들링, 배포, 캐시 관리</td><td>Next.js / Vercel</td></tr></tbody></table><p>React는 이제 RSC의 실행 모델을 공식적으로 제공하고, Next.js는 그 위에 “앱을 어떻게 구성하고, 사용자에게 어떻게 보여줄지”를 책임집니다.</p><p>두 프로젝트가 자연스럽게 분업 구조를 완성한 셈입니다.</p><h2 id="react는-프레임워크가-아니라-표준-을-만듭니다" tabindex="-1">React는 프레임워크가 아니라 “표준”을 만듭니다 <a class="header-anchor" href="#react는-프레임워크가-아니라-표준-을-만듭니다" aria-label="Permalink to “React는 프레임워크가 아니라 “표준”을 만듭니다”">​</a></h2><p>Meta(페이스북) 팀이 React를 만들 때부터 지켜온 원칙이 있습니다.</p><blockquote><p>“React는 View Layer만 담당한다.”</p></blockquote><p>그 말은 지금도 그대로 이어지고 있습니다. React는 <strong>직접 앱을 만들지 않습니다.</strong><br> 대신 <strong>앱을 만드는 사람들이 모두 같은 방식으로 React를 사용할 수 있도록</strong> 기반을 다집니다.</p><p>RSC 역시 그런 시도의 연장선에 있습니다.<br> 서버와 클라이언트의 경계를 React의 언어로 표현하고, 그 위에서 여러 프레임워크가 자유롭게 풀스택을 구현할 수 있도록 한 것이죠.</p><h2 id="정리하며" tabindex="-1">정리하며 <a class="header-anchor" href="#정리하며" aria-label="Permalink to “정리하며”">​</a></h2><p>React Server Component는 “React가 풀스택이 된 기술”이 아닙니다.<br> 그보다는, “풀스택 프레임워크들이 React스럽게 동작할 수 있도록 만든 표준화된 모델”에 가깝습니다.</p><p>React 19는 Next.js App Router가 보여준 실험을 정식화했습니다.<br> Next.js는 이제 React의 정식 런타임 위에서 작동하며, 다른 프레임워크(예: Remix, React Router)도 같은 방식으로 RSC를 구현할 수 있게 되었습니다.</p><p>결국 RSC의 진짜 의미는 아래와 같이 요약할 수 있습니다.</p><blockquote><p>React는 모든 걸 직접 만들지 않습니다.<br> 대신, 모두가 React 위에서 같은 방식으로 만들 수 있도록 돕습니다.</p></blockquote><h2 id="출처-및-참조" tabindex="-1">출처 및 참조 <a class="header-anchor" href="#출처-및-참조" aria-label="Permalink to “출처 및 참조”">​</a></h2><ul><li><a href="https://ko.react.dev/blog/2024/12/05/react-19" target="_blank" rel="noreferrer">https://ko.react.dev/blog/2024/12/05/react-19</a></li><li><a href="https://react.dev/reference/rsc/server-components" target="_blank" rel="noreferrer">https://react.dev/reference/rsc/server-components</a></li><li><a href="https://react.dev/reference/rsc/server-functions" target="_blank" rel="noreferrer">https://react.dev/reference/rsc/server-functions</a></li><li><a href="https://www.joshwcomeau.com/react/server-components" target="_blank" rel="noreferrer">https://www.joshwcomeau.com/react/server-components</a></li></ul></div></div></main><footer class="VPDocFooter" data-v-7011f0d8 data-v-e257564d><!--[--><!--]--><div class="edit-info" data-v-e257564d><!----><div class="last-updated" data-v-e257564d><p class="VPLastUpdated" data-v-e257564d data-v-e98dd255>Last updated: <time datetime="2025-10-15T02:40:51.000Z" data-v-e98dd255></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/%EC%95%84%ED%8B%B0%ED%81%B4/CSS_Cascading_and_Specificity" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>CSS Cascading and Specificity</span><!--]--></a></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/%EC%95%84%ED%8B%B0%ED%81%B4/javascript%EC%9D%98_%EC%95%8C%EB%A9%B4_%EB%BB%94%ED%95%98%EC%A7%80%EB%A7%8C_%EB%AA%B0%EB%9E%90%EC%9D%84_%EC%88%98%EB%8F%84_%EC%9E%88%EB%8A%94_%EB%8F%99%EC%9E%91" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Next page</span><span class="title" data-v-e257564d>javascript의 알면 뻔하지만 몰랐을 수도 있는 동작</span><!--]--></a></div></nav></footer><!--[--><!--[--><!--[--><!--[--><div style="display:none;"></div><div style=""></div><!--]--><!--]--><!--]--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"CYKOA1Pj\",\"블로그_obsidian으로_작성하는_vitepress_블로그.md\":\"Cwklqv8y\",\"아티클_css_cascading_and_specificity.md\":\"C1c5OJEf\",\"아티클_javascript의_알면_뻔하지만_몰랐을_수도_있는_동작.md\":\"CYH-rtZA\",\"아티클_react_server_components에_대한_오해.md\":\"DgCUfbcE\",\"아티클_코드_복잡도를_측정하는_방법.md\":\"31KDL7Hg\",\"아티클_한글_파일명이_읽히지_않는_문제.md\":\"BkZAM5O8\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"logone72\",\"titleTemplate\":\"기술 블로그\",\"description\":\"frontend developer logone72's blog\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"/icons8-dev-30.png\",\"nav\":[{\"text\":\"Home\",\"link\":\"/\"}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/logone72/logone72.github.io.git\"}],\"sidebar\":[{\"text\":\"블로그\",\"items\":[{\"text\":\"obsidian으로 작성하는 VitePress 블로그\",\"link\":\"/블로그/obsidian으로_작성하는_VitePress_블로그\"}]},{\"text\":\"아티클\",\"items\":[{\"text\":\"CSS Cascading and Specificity\",\"link\":\"/아티클/CSS_Cascading_and_Specificity\"},{\"text\":\"React Server Components에 대한 오해\",\"link\":\"/아티클/React_Server_Components에_대한_오해\"},{\"text\":\"javascript의 알면 뻔하지만 몰랐을 수도 있는 동작\",\"link\":\"/아티클/javascript의_알면_뻔하지만_몰랐을_수도_있는_동작\"},{\"text\":\"코드 복잡도를 측정하는 방법\",\"link\":\"/아티클/코드_복잡도를_측정하는_방법\"},{\"text\":\"한글 파일명이 읽히지 않는 문제\",\"link\":\"/아티클/한글_파일명이_읽히지_않는_문제\"}]}],\"search\":{\"provider\":\"local\"},\"outline\":\"deep\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true,\"additionalConfig\":{}}");</script>
    
  </body>
</html>
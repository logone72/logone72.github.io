import{_ as i,c as l,o as t,N as e}from"./chunks/framework.820fbdb1.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"추상화 (Abstraction)","slug":"추상화-abstraction","link":"#추상화-abstraction","children":[]},{"level":2,"title":"캡슐화(Encapsulation)","slug":"캡슐화-encapsulation","link":"#캡슐화-encapsulation","children":[{"level":3,"title":"캡슐화와 은닉화은 차이?","slug":"캡슐화와-은닉화은-차이","link":"#캡슐화와-은닉화은-차이","children":[]}]},{"level":2,"title":"상속(Inheritance)","slug":"상속-inheritance","link":"#상속-inheritance","children":[]},{"level":2,"title":"다형성(Polymorphism)","slug":"다형성-polymorphism","link":"#다형성-polymorphism","children":[]}],"relativePath":"개발/정리본/OOP.md"}'),n={name:"개발/정리본/OOP.md"},r=e('<ol><li><em>추상화</em> (Abstraction)</li><li><em>캡슐화</em> (Encapsulation)</li><li><em>상속</em> (Inheritance)</li><li><em>다형성</em> (Polymorphism)</li></ol><h2 id="추상화-abstraction" tabindex="-1">추상화 (Abstraction) <a class="header-anchor" href="#추상화-abstraction" aria-hidden="true">#</a></h2><p>객체들의 공통적인 특징(속성, 기능)을 뽑아 이름을 붙이는 것</p><ul><li>클래스 VS 객체 <ul><li><strong>클래스</strong> : 분류에 대한 <strong>개념</strong> -&gt; 같은 특성을 지닌 여러 객체를 총칭하는 집합의 개념 (ex.사람)</li><li><strong>객체</strong> : <strong>실체</strong> -&gt; 유일무이한 사물 (ex. 모모)</li></ul></li><li>추상화<br> : 구체적인 것을 분해해서 <strong>관심 영역 (애플리케이션 경계)</strong> 에 있는 특성만 가지고 재조합하는 것 (= 모델링)</li></ul><h2 id="캡슐화-encapsulation" tabindex="-1">캡슐화(Encapsulation) <a class="header-anchor" href="#캡슐화-encapsulation" aria-hidden="true">#</a></h2><p>특정 객체가 독립적으로 역할을 제대로 수행하기 위해 필요한 데이터와 기능을 하나로 묶은 것 (모듈화의 의미)</p><p>정보를 객체 안에 포함시키고, 그 정보에 대한 직접 접근은 허용하지 않는 대신, 필요에 따라 확인할 수 있는 인터페이스를 외부에 공개하는 방식</p><h3 id="캡슐화와-은닉화은-차이" tabindex="-1">캡슐화와 은닉화은 차이? <a class="header-anchor" href="#캡슐화와-은닉화은-차이" aria-hidden="true">#</a></h3><p><strong>은닉화</strong>는 외부에서 객체의 속성을 함부로 접근하지 못하도록 하는 것이다. <strong>캡슐화</strong>는 메서드 안에서 어떠한 일이 일어나고 있는지 모르게 해야한다는 것이다.</p><h2 id="상속-inheritance" tabindex="-1">상속(Inheritance) <a class="header-anchor" href="#상속-inheritance" aria-hidden="true">#</a></h2><p>상위 개념의 특징을 하위 개념이 물려받는 것</p><ul><li><strong>하위 클래스 - 상위 클래스</strong><ul><li>하위 클래스는 상위클래스 특성을 <strong>재사용</strong>하고, <strong>확장</strong>한다.</li><li>상위 클래스의 물려줄 특성이 많을수록 좋다</li></ul></li><li><strong>인터페이스</strong><ul><li>다중 상속 대신 도입</li><li>어떤 객체가 <strong>해야할 일</strong>을 정의하는 <strong>추상</strong> 자료형</li><li>구현 클래스 is able to 인터페이스 (ex. Runnable)</li><li>인터 페이스는 구현을 강제할 메서드가 적을수록 좋다</li></ul></li></ul><h2 id="다형성-polymorphism" tabindex="-1">다형성(Polymorphism) <a class="header-anchor" href="#다형성-polymorphism" aria-hidden="true">#</a></h2><p>모듈이 갖고있는 정체성과 표현방식</p><p>다형성을 극대화 하기 위해 추상클래스나 인터페이스를 이용한다.</p><ul><li>오버라이딩 <ul><li>같은 메서드 이름 / 같은 인자 목록 / 상위 클래스의 메서드 <strong>재정의</strong></li><li>상위 클래스 타입의 객체 참조 변수에서 자동으로 하위 클래스가 오버라이딩한 메소드를 호출해 줌</li></ul></li><li>오버로딩 <ul><li>같은 메서드 이름 / 다른 인자 목록 / 다수의 메서드 <strong>중복 정의</strong></li></ul></li></ul>',16),a=[r];function o(s,c,h,p,d,u){return t(),l("div",null,a)}const _=i(n,[["render",o]]);export{m as __pageData,_ as default};

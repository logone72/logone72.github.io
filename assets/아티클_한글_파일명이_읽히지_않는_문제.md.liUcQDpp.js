import{_ as s,c as a,a4 as l,o as t}from"./chunks/framework.DzR0mKe-.js";const c=JSON.parse('{"title":"한글 파일명이 읽히지 않는 문제, 그리고 개발자로서의 고민","description":"","frontmatter":{},"headers":[],"relativePath":"아티클/한글_파일명이_읽히지_않는_문제.md","filePath":"아티클/한글_파일명이_읽히지_않는_문제.md","lastUpdated":1737468406000}'),o={name:"아티클/한글_파일명이_읽히지_않는_문제.md"};function n(r,i,e,h,g,p){return t(),a("div",null,i[0]||(i[0]=[l(`<h1 id="한글-파일명이-읽히지-않는-문제-그리고-개발자로서의-고민" tabindex="-1">한글 파일명이 읽히지 않는 문제, 그리고 개발자로서의 고민 <a class="header-anchor" href="#한글-파일명이-읽히지-않는-문제-그리고-개발자로서의-고민" aria-label="Permalink to &quot;한글 파일명이 읽히지 않는 문제, 그리고 개발자로서의 고민&quot;">​</a></h1><p>개발을 하다 보면 예상치 못한 문제를 마주할 때가 있습니다. 이번 테스트 서버에서 이미지가 읽히지 않는 상황을 경험했는데, 그 원인을 추적하는 과정에서 한글 파일명과 Unicode의 미묘한 차이, 그리고 운영체제별 처리 방식을 발견했습니다. 이를 통해 한글을 개발에 활용하는 데 있어 고려해야 할 점을 돌아보게 되었습니다.</p><hr><h2 id="문제의-발견-이미지-파일명이-읽히지-않는-상황" tabindex="-1">문제의 발견: 이미지 파일명이 읽히지 않는 상황 <a class="header-anchor" href="#문제의-발견-이미지-파일명이-읽히지-않는-상황" aria-label="Permalink to &quot;문제의 발견: 이미지 파일명이 읽히지 않는 상황&quot;">​</a></h2><p>테스트 서버에서 특정 이미지가 노출되지 않는 문제가 발생했습니다. 흔히 발생할 수 있는 단순한 문제(파일 누락, 경로 오류 등)라고 생각했지만, 확인해보니 파일은 정확한 경로에 존재했고, 문제는 다른 곳에 있었습니다.</p><ol><li><strong>한글 → 영문 변경 시 정상 동작</strong><br> 이미지 파일명을 한글에서 영문으로 바꾸면 문제가 사라집니다.</li><li><strong>동일 서버에서 일부 한글 파일은 정상</strong><br> 모든 한글 파일명이 문제를 일으키는 것은 아니었기에, 더욱 혼란스러웠습니다.</li><li><strong>한글 파일명을 되돌렸더니… 정상 작동?</strong><br> 파일명을 원래 한글로 다시 바꾸었더니 이번에는 정상적으로 동작하는 경우도 있었습니다.</li></ol><p>이 같은 현상은 한글 파일명 자체의 문제라기보다는, <strong>한글이 운영체제나 파일 시스템에 저장될 때 다른 형태로 인식될 수 있다는 점</strong>이 원인이었습니다.</p><hr><h2 id="문제의-원인-한글과-unicode의-관계" tabindex="-1">문제의 원인: 한글과 Unicode의 관계 <a class="header-anchor" href="#문제의-원인-한글과-unicode의-관계" aria-label="Permalink to &quot;문제의 원인: 한글과 Unicode의 관계&quot;">​</a></h2><p>한글을 포함한 모든 문자는 내부적으로 <strong>Unicode</strong>라는 표준에 따라 코드 포인트로 표현됩니다.<br> 하지만 문제는 <strong>같은 한글을 표현하는 방식</strong>이 <strong>조합형(NFC)</strong> 과 <strong>분리형(NFD)</strong> 등으로 나뉠 수 있고, 운영체제나 파일 시스템별로 이를 다르게 취급한다는 데서 발생합니다.</p><p>이를 이해하기 위해 &quot;배너&quot;라는 단어를 예로 들어보겠습니다.</p><h3 id="_1-조합형-nfc-vs-분리형-nfd" tabindex="-1">1. 조합형(NFC) vs. 분리형(NFD) <a class="header-anchor" href="#_1-조합형-nfc-vs-분리형-nfd" aria-label="Permalink to &quot;1. 조합형(NFC) vs. 분리형(NFD)&quot;">​</a></h3><ul><li><strong>조합형(NFC)</strong>:<br> “배너” 같은 단어를 하나의 코드 포인트(예: U+BAA8, U+B124)로 저장</li><li><strong>분리형(NFD)</strong>:<br> 같은 단어도 초성·중성·종성으로 나누어 여러 코드 포인트(예: U+1107, U+1161, …)로 저장</li></ul><h4 id="예시-배너" tabindex="-1">예시: “배너” <a class="header-anchor" href="#예시-배너" aria-label="Permalink to &quot;예시: “배너”&quot;">​</a></h4><ul><li><strong>NFC(조합형)</strong>: <ul><li>배(<code>U+BAA8</code>), 너(<code>U+B124</code>) → “배너”</li></ul></li><li><strong>NFD(분리형)</strong>: <ul><li>(초성 ᄇ) <code>U+1107</code>, (중성 ㅐ) <code>U+1161</code>, (초성 ᄂ) <code>U+1102</code>, (중성 ㅓ) <code>U+1161</code></li><li>결과적으로는 똑같이 “배너”처럼 보이지만, 코드 포인트 배열이 다름</li></ul></li></ul><h3 id="_2-운영체제별-한글-파일명-처리-방식" tabindex="-1">2. 운영체제별 한글 파일명 처리 방식 <a class="header-anchor" href="#_2-운영체제별-한글-파일명-처리-방식" aria-label="Permalink to &quot;2. 운영체제별 한글 파일명 처리 방식&quot;">​</a></h3><ul><li><strong>macOS(APFS)</strong>: 내부적으로 <strong>NFD(분리형)</strong> 를 주로 사용</li><li><strong>Windows(NTFS, FAT)</strong>: 내부적으로 <strong>NFC(조합형)</strong> 을 주로 사용</li><li><strong>Linux(ext4 등)</strong>: 대체로 NFC를 사용하는 편이지만, 배포판이나 설정에 따라 다를 수 있음</li></ul><p>서로 다른 정규화 방식을 사용하는 운영체제 간에 파일을 주고받으면, <strong>같은 “배너.jpg” 파일도 사실은 다른 이름</strong>처럼 취급될 수 있습니다. 이때, 서버에서는 “파일이 이미 존재하는데 왜 못 찾을까?” 하는 혼란이 생기는 것입니다.</p><hr><h2 id="실무에서-흔히-겪는-문제-사례" tabindex="-1">실무에서 흔히 겪는 문제 사례 <a class="header-anchor" href="#실무에서-흔히-겪는-문제-사례" aria-label="Permalink to &quot;실무에서 흔히 겪는 문제 사례&quot;">​</a></h2><ol><li><p><strong>Git 저장소에서의 충돌</strong><br> 맥OS 환경에서 커밋된 파일명이 분리형(NFD)으로 저장되었다면, 윈도우 환경에서 이 저장소를 받아올 때 <strong>파일명이 달라진 것으로 인식</strong>되어 충돌이 발생합니다.</p></li><li><p><strong>CI/CD 파이프라인 실패</strong><br> 빌드 서버(예: Linux)에서 스크립트로 파일들을 복사·배포하는 과정에서, 서버 내부에서 문자 정규화가 섞이면 파일명을 인식하지 못해 스크립트가 실패할 수 있습니다.</p></li><li><p><strong>클라우드 스토리지</strong><br> AWS S3나 GCP Storage에 업로드하는 경우, 한글 파일명을 올렸는데 운영체제에서 NFD/NFC 변환을 다르게 처리해 “파일이 존재하지 않는다”는 에러가 날 때가 있습니다.</p></li></ol><hr><h2 id="unicode-문제-해결을-위한-도구-string-prototype-normalize" tabindex="-1">Unicode 문제 해결을 위한 도구: <code>String.prototype.normalize()</code> <a class="header-anchor" href="#unicode-문제-해결을-위한-도구-string-prototype-normalize" aria-label="Permalink to &quot;Unicode 문제 해결을 위한 도구: \`String.prototype.normalize()\`&quot;">​</a></h2><p>JavaScript에서는 이러한 Unicode 표현 차이를 해결하기 위해 <strong><code>String.prototype.normalize()</code></strong> 메서드를 제공합니다.<br> 문자열을 <strong>NFC</strong>, <strong>NFD</strong>, <strong>NFKC</strong>, <strong>NFKD</strong> 등의 정규화 형태로 변환할 수 있어, <strong>파일명</strong>이나 <strong>문자열 비교</strong> 시 유용합니다.</p><blockquote><p><strong>정규화 형태의 종류</strong></p></blockquote><ol><li><strong>NFC (Canonical Composition)</strong><ul><li>조합형으로 표현.</li><li>예: &quot;배너&quot; → <code>U+BAA8 U+B124</code>.</li></ul></li><li><strong>NFD (Canonical Decomposition)</strong><ul><li>분리형으로 표현.</li><li>예: &quot;배너&quot; → <code>U+1107 U+1161 U+1102 U+1161</code>.</li></ul></li><li><strong>NFKC (Compatibility Composition)</strong><ul><li>NFC와 유사하나, 호환 가능한 문자(예: 형식 문자 등)를 통합.</li><li>예: <code>①</code> → <code>1</code>.</li></ul></li><li><strong>NFKD (Compatibility Decomposition)</strong><ul><li>NFD와 유사하나, 호환 가능한 문자까지 분해.</li><li>예: <code>①</code> → <code>1</code>.</li></ul></li></ol><h3 id="normalize-사용-예시" tabindex="-1"><code>normalize()</code> 사용 예시 <a class="header-anchor" href="#normalize-사용-예시" aria-label="Permalink to &quot;\`normalize()\` 사용 예시&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fileName1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;배너&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// NFC </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fileName2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;배너&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// NFD  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fileName1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fileName2); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// false  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 정규화 후 비교 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fileName1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;NFC&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fileName2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;NFC&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span></code></pre></div><h3 id="어디에-활용할-수-있을까" tabindex="-1">어디에 활용할 수 있을까? <a class="header-anchor" href="#어디에-활용할-수-있을까" aria-label="Permalink to &quot;어디에 활용할 수 있을까?&quot;">​</a></h3><ul><li><strong>파일명 처리</strong>: 업로드된 파일명을 NFC로 통일</li><li><strong>DB 저장 및 검색</strong>: DB에 입력하기 전, 동일한 형태(NFC or NFD)로 변환</li><li><strong>문자열 비교/정렬</strong>: UI에서 문자열 정렬 시, 예기치 못한 순서 꼬임 방지</li></ul><hr><h2 id="한국인-개발자로서-한글-활용의-중요성" tabindex="-1">한국인 개발자로서 한글 활용의 중요성 <a class="header-anchor" href="#한국인-개발자로서-한글-활용의-중요성" aria-label="Permalink to &quot;한국인 개발자로서 한글 활용의 중요성&quot;">​</a></h2><p>한글을 사용하는 데 있어서, 이런 기술적 문제가 때때로 걸림돌이 되기도 합니다. 그럼에도 불구하고 <strong>한글을 적극적으로 활용</strong>하는 것은 다음과 같은 이점이 있습니다.</p><ol><li><strong>의미 전달의 정확성</strong><br> “주택담보대출” 같은 용어는 영어 “Mortgage Loan”으로 어느 정도 설명이 되지만, 세밀한 뉘앙스를 살리기는 어렵습니다.</li><li><strong>효율적이고 직관적인 표현</strong><br> 영어보다 짧은 글자로 풍부한 의미를 담을 수 있어, 변수명·주석 등에서 더 빠른 이해가 가능합니다.</li><li><strong>서비스 특화</strong><br> 국내 사용자 대상으로 서비스를 개발할 때, 영어만 사용하면 오히려 사용성이 떨어집니다. 한글로 기능명이나 에러 메시지 등을 명확히 전달할 수 있습니다.</li></ol><hr><h2 id="한글-활용-시-고려해야-할-점" tabindex="-1">한글 활용 시 고려해야 할 점 <a class="header-anchor" href="#한글-활용-시-고려해야-할-점" aria-label="Permalink to &quot;한글 활용 시 고려해야 할 점&quot;">​</a></h2><ul><li><strong>로케일 설정</strong><ul><li>서버 OS나 DB, 앱 프레임워크 설정에서 한글 로케일이 올바르게 지정되어 있는지 확인</li></ul></li><li><strong>코드 정규화 정책</strong><ul><li>Git, CI/CD 파이프라인 등 협업 환경에서 “파일명·문자열은 항상 NFC로 통일한다” 같은 정책 수립</li></ul></li><li><strong>글로벌 협업 시</strong><ul><li>전 세계 개발자와 협업하거나, 오픈소스 기여 시 한글 변수를 사용할 경우 의사소통 장벽이 생길 수 있으므로 주의</li></ul></li></ul><hr><h2 id="체크리스트-한글-파일명·문자열-처리-시-유의-사항" tabindex="-1">체크리스트: 한글 파일명·문자열 처리 시 유의 사항 <a class="header-anchor" href="#체크리스트-한글-파일명·문자열-처리-시-유의-사항" aria-label="Permalink to &quot;체크리스트: 한글 파일명·문자열 처리 시 유의 사항&quot;">​</a></h2><ol><li><strong>운영체제별/파일 시스템별 한글 처리 방식</strong><ul><li>macOS(NFD), Windows(NFC), Linux(다양) 등 서로 다른 환경 고려</li></ul></li><li><strong>문자열 정규화 로직</strong><ul><li>JavaScript, Python 등에서 제공하는 normalize 함수를 활용해 통일</li></ul></li><li><strong>Git/CI 파이프라인</strong><ul><li>저장소에 올라가는 파일을 자동으로 정규화하는 스크립트 혹은 Git 훅(hook) 설정</li></ul></li><li><strong>DB 및 검색 엔진</strong><ul><li>한글 문자열 검색 시 DB 정규화 정책이 맞는지 확인</li></ul></li><li><strong>협업 가이드</strong><ul><li>팀 내에서 “한글 변수명/파일명 사용 범위”와 “글로벌 협업 시 대안” 등을 미리 합의</li></ul></li></ol><hr><h2 id="결론-한글-지양이-아닌-지향의-대상" tabindex="-1">결론: 한글, 지양이 아닌 지향의 대상 <a class="header-anchor" href="#결론-한글-지양이-아닌-지향의-대상" aria-label="Permalink to &quot;결론: 한글, 지양이 아닌 지향의 대상&quot;">​</a></h2><p>개발자는 문제를 해결하는 사람입니다. 한국인 개발자로서 한글을 적극 활용하면서도, 그 과정에서 예상되는 문제(조합형 vs. 분리형, 운영체제별 차이 등)를 잘 이해하고 관리해야 합니다.</p><p>한글은 우리의 언어이자 강점이며, 더 나은 서비스를 만드는 도구가 될 수 있습니다. “한글 사용 = 문제”가 아니라, “한글 사용 시 나타나는 문제를 해결할 지식과 경험”을 갖추는 것이 중요합니다. 이 과정을 통해 우리는 <strong>국내 개발 환경을 풍요롭게</strong> 만들 수 있을 것입니다.</p><hr><h2 id="참고-자료" tabindex="-1">참고 자료 <a class="header-anchor" href="#참고-자료" aria-label="Permalink to &quot;참고 자료&quot;">​</a></h2><ul><li><strong><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/normalize" target="_blank" rel="noreferrer">MDN - String.prototype.normalize()</a></strong></li><li><strong><a href="https://unicode.org/reports/tr15/" target="_blank" rel="noreferrer">Unicode 표준 Annex #15: Unicode 정규화</a></strong></li><li><strong><a href="https://developer.apple.com/documentation/foundation/file_system/about_apple_file_system" target="_blank" rel="noreferrer">Apple Developer 문서 - 파일 시스템 (APFS)</a></strong></li><li><strong><a href="https://docs.microsoft.com/ko-kr/windows/win32/fileio/naming-a-file" target="_blank" rel="noreferrer">Microsoft Docs - Windows의 파일 이름, 경로, 네임스페이스</a></strong></li></ul>`,47)]))}const k=s(o,[["render",n]]);export{c as __pageData,k as default};

import{_ as e,c as a,o as t,N as s}from"./chunks/framework.67628f14.js";const j=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"js에서 우리는 왜 타입 체크를 했었나?","slug":"js에서-우리는-왜-타입-체크를-했었나","link":"#js에서-우리는-왜-타입-체크를-했었나","children":[{"level":3,"title":"1. 개발 과정에서의 휴먼 에러","slug":"_1-개발-과정에서의-휴먼-에러","link":"#_1-개발-과정에서의-휴먼-에러","children":[]},{"level":3,"title":"2. 서버 명세 반영 실패","slug":"_2-서버-명세-반영-실패","link":"#_2-서버-명세-반영-실패","children":[]},{"level":3,"title":"3. 코드 실행 환경 문제","slug":"_3-코드-실행-환경-문제","link":"#_3-코드-실행-환경-문제","children":[]}]}],"relativePath":"개발/메모/stacks/js,-ts의-런타임-타입-체크---W.md"}'),i={name:"개발/메모/stacks/js,-ts의-런타임-타입-체크---W.md"},_=s('<p>typescript를 사용하게 되니, 반복적인 변수의 타입 체크에서 해방 될 수 있었다.</p><p>typescript가 없는 세상 속에서의 js에서의 코드 작성은 그림자 속에 숨은 암살자를 경계하며 던전을 나아가는것 같았다. 개울의 돌다리도 두드려보고 건너듯이, 함수별로 의도된 인자가 넘어오지 않은 상황을 대비해야했다.</p><p>js는 인터프리터 언어이다. 동적으로 실행되는 단계에서 변수들의 타입들이 확정되기에 모든 타입 체킹을 runtime에서 진행해야했다. ts라는 js의 슈퍼셋 언어가 등장하면서 컴파일 단계에서의 타입 체킹이 가능해졌다.</p><h2 id="js에서-우리는-왜-타입-체크를-했었나" tabindex="-1">js에서 우리는 왜 타입 체크를 했었나? <a class="header-anchor" href="#js에서-우리는-왜-타입-체크를-했었나" aria-hidden="true">#</a></h2><p>그렇게 ts 프로젝트를 진행하면서 불현듯 어떤 생각이 떠올랐다.</p><blockquote><p>__왜 우리는 vanilla js 시절 변수의 타입 체크를 했었지?</p></blockquote><p>생각나는 케이스는 아래와 같다.</p><ol><li>개발 과정에서의 휴먼 에러</li><li>서버 명세 반영 실패</li><li>코드 실행 환경 문제</li></ol><h3 id="_1-개발-과정에서의-휴먼-에러" tabindex="-1">1. 개발 과정에서의 휴먼 에러 <a class="header-anchor" href="#_1-개발-과정에서의-휴먼-에러" aria-hidden="true">#</a></h3><p>1번의 경우, 타입을 지원하지 않는 javascript 특성상 코드 라이팅 단계에서 실수로 특정 함수의 리턴 값 혹은 인자의 값의 타입을 실제와는 다르게 인지하고 작성하는 경우가 생긴다.</p><p>개발자가 뛰어난 실력으로 이리저리 넘어다니는 값들의 타입을 모두 알고 통제할 수 있으면 좋겠지만, 주니어부터 시니어까지 다양한 사람들이 함께 작업하는 다인 프로젝트나 프로젝트 규모가 비대해진다면 이는 불가능에 가깝다.</p><p>이러한 휴먼 에러를 훌륭하게 해결해주는 것이 타입스크립트이기에 1번은 더이상 문제가 아니다.</p><h3 id="_2-서버-명세-반영-실패" tabindex="-1">2. 서버 명세 반영 실패 <a class="header-anchor" href="#_2-서버-명세-반영-실패" aria-hidden="true">#</a></h3><p>웹 개발이 고도화되며 프론트와 백으로 전문성이 분기되었다. 우리는 API를 통해서 소통하여 위대한 프로젝트를 완성시킨다. 하지만 우리는 다른 길을 떠난만큼 (그리고 web 통신의 문제점들) 서로에 대해서 알기위해 많은 것을 공유해야한다.</p><p>기업 단위의 프로젝트에서는 당연히 백엔드에서 작업한 API가 업데이트 되어 유의미한 변경사항이 있을때마다 공유하여 프론트에서 적절히 대응하는 프로세스가 준비되어있다.</p><p>하지만 이 과정은 사람이 하기에 반드시 문제가 생기게 되어있다.</p><h3 id="_3-코드-실행-환경-문제" tabindex="-1">3. 코드 실행 환경 문제 <a class="header-anchor" href="#_3-코드-실행-환경-문제" aria-hidden="true">#</a></h3><p>명확한 logic을 기반으로 작성된 가상의 코드 세계에서 에러란 \b존재하지 않았을 것이다. 하지만 현실세계에서 이 코드가 실행되는 과정에서 수많은 위험을 마주하게 된다. 서버와 데이터 전송과정에서 물리적으로 데이터 송수신이 망가질 수도 있고, 완벽해보이는 전자기기들이 눈에 띄지 않은 이유로 굳이 내 코드가 실행되는 시점에 오류를 만들어 낼 수도 있다.</p><p>이러한 상황은 일반적인 웹 개발 단계에서 고려하기엔 비용이 너무 크기에 (우주 공학에서는 필수이다) 일반적으로 고려대상은 아닌 것 같다.</p><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h1>',20),r=[_];function l(p,n,c,d,h,o){return t(),a("div",null,r)}const f=e(i,[["render",l]]);export{j as __pageData,f as default};

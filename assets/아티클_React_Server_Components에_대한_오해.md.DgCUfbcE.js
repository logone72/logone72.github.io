import{_ as s,c as a,o as e,aj as i}from"./chunks/framework.EaxRB2c3.js";const k=JSON.parse('{"title":"React Server Components에 대한 오해","description":"","frontmatter":{},"headers":[],"relativePath":"아티클/React_Server_Components에_대한_오해.md","filePath":"아티클/React_Server_Components에_대한_오해.md","lastUpdated":1760496051000}'),r={name:"아티클/React_Server_Components에_대한_오해.md"};function n(p,t,l,h,d,o){return e(),a("div",null,[...t[0]||(t[0]=[i(`<h1 id="react-server-components에-대한-오해" tabindex="-1">React Server Components에 대한 오해 <a class="header-anchor" href="#react-server-components에-대한-오해" aria-label="Permalink to “React Server Components에 대한 오해”">​</a></h1><p><img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/f_auto/v1617437062/patterns.dev/reactServerComponents.png" alt=""></p><p><strong>React Server Components(RSC)</strong> 라는 명칭을 보면서 아래와 같은 궁금증이 개인적으로 생겼었습니다.</p><blockquote><p>“React가 풀스택 프레임워크가 된 건가?”</p></blockquote><p>하지만 실제로 React 19를 조금만 자세히 들여다보면, 이야기가 달랐습니다.<br> React는 여전히 <strong>UI 라이브러리</strong>이고, 풀스택의 모든 부분을 담당하는 건 <strong>Next.js</strong> 같은 프레임워크의 몫입니다.</p><p>다만, 이번에는 그 둘이 훨씬 더 깊게 연결되었습니다.</p><p>React가 직접 “서버-클라이언트 경계를 어떻게 정의하고, 어떤 데이터를 주고받을지”에 대한 <strong>표준 언어</strong>를 만든 것이죠.</p><h2 id="rsc는-새로운-프레임워크가-아니라-렌더링-모델-입니다" tabindex="-1">RSC는 새로운 프레임워크가 아니라 “렌더링 모델”입니다 <a class="header-anchor" href="#rsc는-새로운-프레임워크가-아니라-렌더링-모델-입니다" aria-label="Permalink to “RSC는 새로운 프레임워크가 아니라 “렌더링 모델”입니다”">​</a></h2><p>RSC는 “React가 서버에서 돌아가는 새로운 버전”이 아닙니다.<br> 그보다는, <strong>React 컴포넌트를 어디에서, 어떤 방식으로 렌더링할지 정의한 모델</strong>이라고 이해하시면 좋습니다.</p><p>핵심 개념은 단순합니다.</p><blockquote><p>“일부 React 컴포넌트는 브라우저가 아니라 서버에서 렌더링할 수 있다.”</p></blockquote><p>여기서 서버란 웹 서버만을 지칭하지 않습니다. <strong>Server Component</strong>는 번들링 전에 클라이언트 애플리케이션 또는 SSR 서버와 분리된 환경에서 컴포넌트를 미리 렌더링할 수 있는 새로운 옵션입니다. 이 별도의 환경이 RSC에서 <strong>“서버”</strong> 입니다.</p><p>예를 들어 아래 코드를 보겠습니다.</p><div class="language-tsx"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// app/page.tsx</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UserCard </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./UserCard&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://api.example.com/me&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello, {user.name}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UserCard</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>이 컴포넌트는 <strong>Server Component</strong>로 동작합니다.<br> 데이터 패칭(<code>fetch</code>)은 서버에서 이루어지고, React는 이 컴포넌트를 서버에서 렌더링한 뒤 그 결과를 브라우저로 스트리밍합니다.</p><p>이때 브라우저로 전송되는 건 완성된 HTML이 아니라, <strong>RSC Payload(Flight Data)</strong> 라는 React 고유의 데이터 포맷입니다. React DOM은 서버에서 전달된 RSC Payload를 해석해, 클라이언트에서 이미 로드된 컴포넌트 트리와 병합합니다.</p><p>즉, RSC는 전통적인 SSR(Server-Side Rendering)과는 다릅니다.</p><p>전통적인 SSR은 서버에서 HTML을 완성해 보내지만, RSC는 서버에서 React 트리를 렌더링하고, 그 결과를 Flight 포맷으로 직렬화해 브라우저로 전송합니다. 브라우저에서는 이 데이터를 React DOM이 해석해 클라이언트 트리와 병합(hydration과 유사하지만 다른)합니다.</p><h2 id="rsc는-ssr을-대체하는-것인가요" tabindex="-1">RSC는 SSR을 대체하는 것인가요? <a class="header-anchor" href="#rsc는-ssr을-대체하는-것인가요" aria-label="Permalink to “RSC는 SSR을 대체하는 것인가요?”">​</a></h2><p>그렇다면 RSC를 사용하면 이제 SSR이 필요 없을까요? 그렇지 않습니다.</p><p>실제로는 <strong>RSC와 SSR은 서로 다른 층(layer)에 존재하는 개념</strong>입니다.</p><p>SSR은 <strong>“어디서 HTML을 생성하느냐”</strong> 에 관한 이야기이고, RSC는 <strong>“어디서 어떤 컴포넌트를 실행하느냐”</strong> 에 관한 이야기입니다.</p><p>즉, SSR은 렌더링 결과물(HTML)의 생성 위치를 다루고, RSC는 렌더링 과정에서의 <strong>컴포넌트 실행 위치(서버 vs 클라이언트)</strong> 를 다룹니다.</p><p>그래서 RSC를 사용한다고 해서 SSR이 사라지는 것은 아닙니다.</p><p>대신 두 기술은 <strong>서로를 보완하며 함께 동작</strong>합니다.</p><p>예를 들어, SSR은 첫 화면의 HTML을 빠르게 전달하고, RSC는 그 안의 React 트리를 서버에서 효율적으로 렌더링해 스트리밍합니다.</p><h2 id="react-19가-rsc를-지원한다-는-말의-의미" tabindex="-1">React 19가 “RSC를 지원한다”는 말의 의미 <a class="header-anchor" href="#react-19가-rsc를-지원한다-는-말의-의미" aria-label="Permalink to “React 19가 “RSC를 지원한다”는 말의 의미”">​</a></h2><p>React 19가 RSC를 안정적으로 지원한다는 건 이제 React 자체가 서버에서 날아오는 RSC 데이터를 <strong>이해하고 조립할 수 있는 런타임</strong>을 내장하게 되었다는 뜻입니다.</p><p>React 19에는 이런 기능들이 새롭게 들어왔습니다.</p><ul><li><strong>RSC Payload(Flight protocol) 디코딩 기능</strong></li><li><strong><code>react-server</code> export condition</strong> (서버 전용 모듈 인식)</li><li><strong><code>use</code> 훅</strong> (Promise를 <code>Suspense</code>와 함께 다루기)</li><li><strong>Server Actions</strong> (클라이언트에서 서버 함수를 호출)</li><li><strong><code>&lt;form action&gt;</code> 통합</strong> (서버 액션과 폼 제출 연결)</li><li><strong>스타일 및 메타데이터 호이스팅</strong> (SSR과 CSR 간 일관성 보장)</li></ul><p>이 모든 것은 프레임워크가 구현하기 위한 <strong>표준 인터페이스</strong>로 제공됩니다. 즉, React 19는 이제 “RSC를 해석하고 관리할 수 있는 공통 엔진”을 갖게 된 것입니다.</p><h2 id="프레임워크는-여전히-필요합니다" tabindex="-1">프레임워크는 여전히 필요합니다 <a class="header-anchor" href="#프레임워크는-여전히-필요합니다" aria-label="Permalink to “프레임워크는 여전히 필요합니다”">​</a></h2><p>React가 RSC의 표준을 제시했다고 해서, React 혼자서 모든 걸 처리하는 것은 아닙니다.</p><p>다음과 같은 부분들은 여전히 프레임워크나 번들러가 담당합니다.</p><table tabindex="0"><thead><tr><th>역할</th><th>담당</th></tr></thead><tbody><tr><td>라우팅 및 페이지 구성</td><td>Next.js, Remix</td></tr><tr><td>서버 실행 및 스트리밍 응답</td><td>Next.js</td></tr><tr><td>번들 분리 (<code>use client</code>, <code>use server</code>)</td><td>Webpack, Vite, Turbopack</td></tr><tr><td>캐싱, 재검증, 데이터 패칭</td><td>프레임워크</td></tr><tr><td>빌드 및 배포</td><td>인프라 도구들</td></tr></tbody></table><p>React는 <strong>“표준 언어”를 제공</strong>하고, 그 언어로 “앱”을 구성하는 것은 프레임워크의 일입니다.</p><p>이 점에서 React는 여전히 <strong>“UI 라이브러리”</strong> 의 철학을 유지하고 있습니다.</p><h2 id="next-js-app-router-rsc의-첫-번째-실험실" tabindex="-1">Next.js App Router: RSC의 첫 번째 실험실 <a class="header-anchor" href="#next-js-app-router-rsc의-첫-번째-실험실" aria-label="Permalink to “Next.js App Router: RSC의 첫 번째 실험실”">​</a></h2><p>Next.js가 <strong>App Router</strong>를 발표했을 때, 그건 사실 React Server Component를 세상에서 가장 먼저, 그리고 가장 깊이 실험한 사례였습니다.</p><p>App Router는 React 18을 기반으로 만들어졌지만, RSC는 당시 React 18의 정식 API가 아니었습니다.<br> 그래서 Next.js는 React의 <strong>canary(실험)</strong> 버전을 직접 가져다 썼습니다.</p><div class="language-perl"><button title="Copy Code" class="copy"></button><span class="lang">perl</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@13</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">└── react@canary</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ├─ RSC 런타임(Flight 디코더)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ├─ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() 훅</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ├─ Server Actions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    └─ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> server / </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> client</span></span></code></pre></div><p>즉, App Router는 React의 공식 API를 쓰지 않고, React 내부 코드를 직접 활용했던 일종의 <strong>실험적 구현체</strong>였습니다.</p><p>그래서 “안정 버전”이 아닌 “실험적 기능”으로 분류될 수밖에 없었습니다.</p><h2 id="react-19에서-app-router가-완전히-자리를-잡았습니다" tabindex="-1">React 19에서 App Router가 완전히 자리를 잡았습니다 <a class="header-anchor" href="#react-19에서-app-router가-완전히-자리를-잡았습니다" aria-label="Permalink to “React 19에서 App Router가 완전히 자리를 잡았습니다”">​</a></h2><p>React 19에서는 Next.js가 실험적으로 의존하던 기능들이 모두 React의 정식 API로 편입되었습니다.</p><table tabindex="0"><thead><tr><th>기능</th><th>React 18 시절</th><th>React 19 이후</th></tr></thead><tbody><tr><td>RSC payload 디코딩</td><td>Next.js 내부 구현</td><td>React DOM 내장</td></tr><tr><td><code>use</code> 훅</td><td>실험적</td><td>정식</td></tr><tr><td>Server Actions</td><td>실험적</td><td>정식</td></tr><tr><td><code>react-server</code> 조건</td><td>없음</td><td>정식</td></tr><tr><td><code>&lt;form action&gt;</code> 통합</td><td>Next.js 전용</td><td>React DOM 지원</td></tr><tr><td>메타데이터/스타일 호이스팅</td><td>Next.js 내부 처리</td><td>React DOM 내장</td></tr></tbody></table><p>이제 App Router는 React의 정식 버전만으로도 안정적으로 작동합니다.<br> React와 Next.js가 각자 독립적으로 발전하면서도, <strong>RSC라는 표준 언어로 완전히 호환</strong>되는 구조가 된 것입니다.</p><h2 id="react와-next-js의-역할이-다시-명확해졌습니다" tabindex="-1">React와 Next.js의 역할이 다시 명확해졌습니다 <a class="header-anchor" href="#react와-next-js의-역할이-다시-명확해졌습니다" aria-label="Permalink to “React와 Next.js의 역할이 다시 명확해졌습니다”">​</a></h2><p>React 19 이후 두 프로젝트의 관계는 다음과 같이 정리됩니다.</p><table tabindex="0"><thead><tr><th>계층</th><th>역할</th><th>담당</th></tr></thead><tbody><tr><td>React Core</td><td>RSC 런타임, Flight 프로토콜, Suspense, Server Actions 등</td><td>React</td></tr><tr><td>Integration Layer</td><td>RSC 렌더링, 스트리밍, 번들 매핑</td><td>Next.js</td></tr><tr><td>Routing &amp; Data Layer</td><td>파일 라우팅, 캐싱, 데이터 패칭</td><td>Next.js</td></tr><tr><td>Build &amp; Infra</td><td>번들링, 배포, 캐시 관리</td><td>Next.js / Vercel</td></tr></tbody></table><p>React는 이제 RSC의 실행 모델을 공식적으로 제공하고, Next.js는 그 위에 “앱을 어떻게 구성하고, 사용자에게 어떻게 보여줄지”를 책임집니다.</p><p>두 프로젝트가 자연스럽게 분업 구조를 완성한 셈입니다.</p><h2 id="react는-프레임워크가-아니라-표준-을-만듭니다" tabindex="-1">React는 프레임워크가 아니라 “표준”을 만듭니다 <a class="header-anchor" href="#react는-프레임워크가-아니라-표준-을-만듭니다" aria-label="Permalink to “React는 프레임워크가 아니라 “표준”을 만듭니다”">​</a></h2><p>Meta(페이스북) 팀이 React를 만들 때부터 지켜온 원칙이 있습니다.</p><blockquote><p>“React는 View Layer만 담당한다.”</p></blockquote><p>그 말은 지금도 그대로 이어지고 있습니다. React는 <strong>직접 앱을 만들지 않습니다.</strong><br> 대신 <strong>앱을 만드는 사람들이 모두 같은 방식으로 React를 사용할 수 있도록</strong> 기반을 다집니다.</p><p>RSC 역시 그런 시도의 연장선에 있습니다.<br> 서버와 클라이언트의 경계를 React의 언어로 표현하고, 그 위에서 여러 프레임워크가 자유롭게 풀스택을 구현할 수 있도록 한 것이죠.</p><h2 id="정리하며" tabindex="-1">정리하며 <a class="header-anchor" href="#정리하며" aria-label="Permalink to “정리하며”">​</a></h2><p>React Server Component는 “React가 풀스택이 된 기술”이 아닙니다.<br> 그보다는, “풀스택 프레임워크들이 React스럽게 동작할 수 있도록 만든 표준화된 모델”에 가깝습니다.</p><p>React 19는 Next.js App Router가 보여준 실험을 정식화했습니다.<br> Next.js는 이제 React의 정식 런타임 위에서 작동하며, 다른 프레임워크(예: Remix, React Router)도 같은 방식으로 RSC를 구현할 수 있게 되었습니다.</p><p>결국 RSC의 진짜 의미는 아래와 같이 요약할 수 있습니다.</p><blockquote><p>React는 모든 걸 직접 만들지 않습니다.<br> 대신, 모두가 React 위에서 같은 방식으로 만들 수 있도록 돕습니다.</p></blockquote><h2 id="출처-및-참조" tabindex="-1">출처 및 참조 <a class="header-anchor" href="#출처-및-참조" aria-label="Permalink to “출처 및 참조”">​</a></h2><ul><li><a href="https://ko.react.dev/blog/2024/12/05/react-19" target="_blank" rel="noreferrer">https://ko.react.dev/blog/2024/12/05/react-19</a></li><li><a href="https://react.dev/reference/rsc/server-components" target="_blank" rel="noreferrer">https://react.dev/reference/rsc/server-components</a></li><li><a href="https://react.dev/reference/rsc/server-functions" target="_blank" rel="noreferrer">https://react.dev/reference/rsc/server-functions</a></li><li><a href="https://www.joshwcomeau.com/react/server-components" target="_blank" rel="noreferrer">https://www.joshwcomeau.com/react/server-components</a></li></ul>`,64)])])}const g=s(r,[["render",n]]);export{k as __pageData,g as default};
